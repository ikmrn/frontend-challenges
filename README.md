# Frontend Mentor - Rock, Paper, Scissors solution

This is a solution to the [Rock, Paper, Scissors challenge on Frontend Mentor](https://www.frontendmentor.io/challenges/rock-paper-scissors-game-pTgwgvgH). Frontend Mentor challenges help you improve your coding skills by building realistic projects.

## Table of contents

- [Frontend Mentor - Rock, Paper, Scissors solution](#frontend-mentor---rock-paper-scissors-solution)
  - [Table of contents](#table-of-contents)
  - [Overview](#overview)
    - [The challenge](#the-challenge)
    - [Screenshot](#screenshot)
    - [Links](#links)
  - [My process](#my-process)
    - [Built with](#built-with)
    - [What I learned](#what-i-learned)
    - [Continued development](#continued-development)
  - [Author](#author)

## Overview

### The challenge

- View the optimal layout for the game depending on their device's screen size
- Play Rock, Paper, Scissors against the computer
- Maintain the state of the score after refreshing the browser _(optional)_

### Screenshot

![screenshot](images/screenshot.png)

### Links

- Solution URL: [GitHub Repository](https://github.com/ikmrn/frontend-challenges/tree/rock-paper-scissors)
- Live Site URL: [Live demo on Netlify](https://ikmrn-rock-paper-scissors.netlify.app/)

## My process

### Built with

- Semantic HTML5 markup
- CSS custom properties
- Flexbox
- CSS Grid
- Mobile-first workflow
- JavaScript for interactivity and game logic
- Local storage for storing game state
- Responsive design for mobile and desktop devices
- Animation effects for enhanced user experience

### What I learned

This project helped me improve my coding skills and taught me the importance of structured project management. Using this structure, I learned a lot about animation in the project function pipeline. I utilized the sleep function to introduce delays in the JavaScript script, creating a more engaging and natural game flow.

Furthermore, I enhanced my understanding of CSS Grid, which enabled me to create flexible and responsive layouts for different screen sizes. Regarding user interaction, I implemented a mechanism to manage the game state. When a player clicks on an option, the game dynamically updates the UI to display the result without reloading the page. This approach allowed me to practice manipulating states effectively.

Additionally, I delved into storing game results locally using the browser's local storage feature. This enabled me to persist the game's state, including the score, even after the user refreshes the page. This practice further solidified my knowledge of managing and storing data within web applications.

### Continued development

In future projects, I aim to further explore and refine my skills in JavaScript, particularly in implementing more complex game mechanics and improving the user interface with additional animations and transitions. Additionally, I plan to deepen my understanding of local storage usage to store more complex game states and user preferences efficiently.

## Author

- Frontend Mentor - [@ikmrn](https://www.frontendmentor.io/profile/ikmrn)
